### Python中一切皆对象，即使是int和float都是对象。

CPython中有一个PyObject结构体，其他的Python对象都使用这个结构。PyObject是所有Python对象的祖父，包含两个域：

+ ob_refcnt：引用计数，用于垃圾回收
+ ob_type：指向另一个类型，即一个描述Python对象（如dict或int）的结构体

每个Python对象都有自己的内存分配器和回收器

Python缓存了整数和短字符串，因此每个对象在内存中只存在一份，引用所指的对象是相同的，使用赋值语句只是创造了新的引用而不是新的对象

Python没有缓存长字符串、列表及其他的对象

### 全局解释器锁（The Global Interpreter Lock, GIL)

GIL是用来处理共享资源的。当两个线程想要更改同一个

### 引用计数

引用增加的情况：

+ 当将一个变量（标签）分配给一块内存区域时，对这块区域的引用加一

  ```python
  numbers = [1, 2, 3]
  # 引用计数为1
  ```

+ 把一个变量赋值给另一个变量

  ```python
  more_numbers = numbers
  # 引用计数为2
  ```

+ 当将一个变量当作一个参数传递给函数时，引用计数加一

  ```python
  total = sum(numbers)
  # 在sum函数作用域内部引用计数为3
  # 返回之后引用计数还是2
  ```

+ 一个对象作为另一个容器对象的元素，即另一个对象内部引用该对象是时，引用计数加一

  ```python
  matrix = [numbers, numbers, numbers]
  # 引用计数为5（2+3）
  ```

可通过sys模块查看对象的当前引用计数：

```python
sys.getrefcount(numbers)
```

但要注意将numbers作为参数传入getrefcount()本身就使引用计数加一（为什么？）

引用计数减少的情况：

+ 对象的别名被显示销毁

  ```python
  a = 1
  # 整数1这个对象引用计数为1
  b = a
  # 引用计数为2
  del b
  # 引用计数为1
  ```

+ 对象的一个别名赋给其他值

  ```python
  c = a
  # 整数1这个对象引用计数为2
  c = 2
  # c原来是指向1的，现在指向2，整数1的引用计数减一，为1
  ```

+ 对象从另一个引用它的对象中移除（list调用的remove方法或对象调用__delattr方法），或引用他的对象本身被销毁

  ```python
  numbers = [1, 2, 3]
  # 引用加一
  numbers.remove(1)
  # 引用减一
  
  # 或者
  del numbers
  # 引用也减一
  ```

+ 一个本地引用离开了它的作用域

  比如在一个函数里引用了a，在这个函数作用域内a的引用计数加一，离开了这个作用域减一

### 内存分配细节

如果一个对象需要分配内存空间吗，实际分配的空间大小是向上取到8的倍数（字节），如需要42字节的空间，实际分配48字节。

### 垃圾回收

当一个Python对象的引用变为0时，对应的内存将会被回收。

### 内存池机制

内存池由块（block）组成，双向链表将这些块链接起来，