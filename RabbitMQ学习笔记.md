## RabbitMQ学习笔记

### 什么是MQ

消息是指在应用之间传送的数据。

MQ是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。

### 消息中间件的作用

+ 解耦
+ 冗余（存储）
+ 扩展性
+ 削峰
+ 缓冲
+ 异步通信

### RabbitMQ的结构

![image-20210602144000526](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210602144000526.png)

1. Broker：消息中间件的服务节点，或者RabbitMQ的服务实例

2. Queue：队列，是RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一个队列，这时队列中的消息会被轮询给多个消费者处理。

3. Exchange：交换器，生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中，如果路由不到或许会返回给生产者，或许直接丢弃。

4. Routing Key：路由键，生产者将消息发送给交换器的时候，一般会指定一个Routing Key，用来指定这个消息的路由规则，而这个Routing Key需要与交换器类型和绑定键联合使用才能最终生效。

5. Binding：绑定，RabbitMQ通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就知道如何正确地将消息路由到队列。

   当路由键和绑定键相匹配时，消息会被路由到对应的队列中。

### 交换器类型

1. fanout：会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。无视路由键。
2. direct：会把消息路由到那些Binding Key和Routing Key完全匹配的队列中。
3. topic：支持模糊匹配，路由键和绑定键为一个点号"."分隔的字符串。存在两种特殊字符串，"*"和"#"，星号匹配一个单词，井号匹配0个或多个单词。
4. headers： headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。（基本上不会使用）

#### RabbitMQ运转流程

生产者：

1. 生产者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
2. 生产者声明一个交换器，并设置相关属性，如交换机类型，是否持久化等。
3. 生产者声明一个队列并设置相关属性，比如是否排他，是否持久化，是否删除等。
4. 生产者通过路由键将交换机和队列绑定起来。
5. 生产者发送消息到RabbitMQ Broker，其中包含路由键、交换器等信息。
6. 相应的交换器根据收到的路由键查找相匹配的队列。
7. 如果找到，则将从生产者发送过来的消息存入相应的队列中。
8. 如果没有找到，则根据生产者配置的属性选择丢弃还是退回个生产者。
9. 关闭信道。
10. 关闭连接。

消费者：

1. 消费者连接到RabbitMQ Broker，建立一个连接（Connection），开启一个信道（Channel）。
2. 消费者向RabbitMQ Broker请求消费相应队列中的消息，可能会设置相应的回调函数，以及一些准备工作。
3. 等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接收消息。
4. 消费者确认（ack）接收到的消息。
5. RabbitMQ从队列中删除相应的已被确认的消息。
6. 关闭信道。
7. 关闭连接。

连接就是一条TCP连接，信道是建立在连接上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。

为什么引入信道？

一个进程中有很多个线程需要从RabbitMQ中消费消息或生产消息，那么必然需要建立很多个连接，即多个TCP连接。对于OS而言，建立和销毁TCP连接是非常昂贵的开销，所以选择复用TCP连接，不仅能减少性能开销，同时便于管理。

### AMQP协议

分三层：

+ Module Layer：位于协议的最高层，主要定义了一些供客户端调用的命令。
+ Session Layer：位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，为客户端和服务器之间的通信提供可靠性同步机制和错误处理。
+ Transport Layer：位于最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。

### 客户端

Channel实例不能再线程间共享，应用程序应该为每个线程开辟一个Channel。多线程间共享Channel实例是非线程安全的。

RabbitMQ的消费模式分两种：推（Push）模式和拉（Pull）模式。推模式采用Basic.Consume进行消费，而拉模式则调用Basic.Get进行消费。

Basic.Consume将信道设置为接收模式，直到取消队列的订阅为止。在接收模式期间，RabbitMQ会不断地推送消息给消费者，当然推送消息地个数还是会受到Basic.Qos的限制。如果只想从队列中获取单条消息而不是持续订阅，建议使用Basic.Get进行消费。如果要实现高吞吐量，消费者理应使用Basic.Consume消费。

RabbitMQ不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递的唯一依据是消费该消息的消费者是否已经断开连接。

#### 未被正确投递的消息

channel.basicPublish方法有一个参数：mandatory

当这个参数设置为true时，交换器无法根据自身的类型和路由键找到一个符合条件的队列时，那么RabbitMQ将会调用Basic.Return命令将消息返回给生产者。设置为false时，出现上述情形，直接丢弃。

如果设置了备份交换器，且未设置mandatory参数，那么未被路由的消息存储通过备份交换器存储。

### 过期时间（TTL）

两种方式设置消息的TTL：

+ 通过队列属性设置，队列中所有的消息都有相同的过期时间
+ 对消息本身单独设置

如果两者一起使用，则以较小的为准。

### 死信队列

DLX（Dead Letter Exchange），称之为死信交换器，当消息在一个队列中变成死信之后，它就被发送到DLX中。

消息变成死信由于一下几种情况：

+ 消息被拒绝（Basic.Reject/Basic.Nack），并且设置requeue参数为false
+ 消息过期
+ 队列达到最大长度

DLX也是一个正常的交换器，和一般的交换器没什么区别。

### 延迟队列

延迟消息：当消息被发送后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

使用场景：订单30分钟没有支付则取消。

AMQP没有支持延迟队列，但可以通过DLX和TTL模拟。

假设一个应用中需要将每条消息设置10秒延迟，生产者通过exchange.normal这个交换器将发送的消息存储在queue.normal中。消费者订阅的并非是这个队列，而是queue.dlx这个队列。当消息从queue.normal过期，被放入queue.dlx中，消费者就能消费到延迟10秒的消息。

### 优先级队列

可以通过x-max-priority参数实现。

### 持久化

1. 交换器的持久化

   通过在声明交换器时将durable参数设置为true实现。持久化的是交换器的元数据，而不是消息。

2. 队列的持久化

   通过在声明队列时将durable参数设置为true实现。持久化的是队列的元数据，不是消息。

3. 消息的持久化

   通过将消息的投递模式（BasicProperties中的deliverMode）设置为2即可实现消息的持久化。

单单设置消息的持久化，而不设置队列的持久化，重启之后队列消失，继而消息也丢失。

将交换器、队列、消息都设置了持久化后，消息也不能保证百分百不丢失。

如果消费者将自动确认设置为true，当消费者接收到相关消息后没来得及处理就宕机了，这样数据就丢失了。可以将autoAck参数设置为false解决，并进行手动确认。

其次，RabbitMQ不会为每条消息都进行同步存盘，可能仅仅保存到操作系统缓存中。如果这时宕机，消息将会丢失。引入镜像队列机制，相当于配置了一个副本，如果主节点挂掉，自动却换到从节点。

还可在发送端引入事务机制，或者发送方确认机制来保证消息已经正确发送并存入磁盘。

### 生产者确认

默认情况下，发送消息的操作是不会返回任何消息给生产者的，也就是说默认情况下生产者不知道消息有没有正确到达服务器。

通过两种方式解决这个问题：

+ 事务机制
+ 发送方确认机制

#### 事务机制

channel.txSelect：将当前信道设置成事务模式

channel.txCommit：提交事务

channel.txRollback：事务回滚

事务机制十分影响性能。

#### 发送方确认机制

生产者将信道设置成确认（conform）模式，一旦信道进入确认模式，所有在该信道上面发布的消息都会被指派一个唯一的ID，一旦消息被投递到所匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一ID），这就使得生产者知晓消息已经正常到达。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。

事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。而确认机制使异步的。

如果RabbitMQ因为自身错误导致消息丢失，发送一条nack（Basic.Nack）命令。

channel.confirmSelect将信道设置为确认模式。

### channel.BasicQos

这个方法限制信道上的消费者所能保持的最大未确认消息的数量。

### 保证消息的顺序性

在消息体内添加全局有序标识。

#### 防止重复消费

在服务器上不能实现，去重处理一般是在客户端实现的。比如引入全局唯一标识来标识每一条消息，在客户端判断该消息是否被消费。还可以让消息实现幂等性，多次重复消费不会产生影响。



