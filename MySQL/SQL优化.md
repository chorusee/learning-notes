### SQL优化

![image-20210531163853803](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210531163853803.png)

大多数MySQL的核心服务功能都在第二层，包括查询解析、分析、优化、缓存及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

对SELECT语句，在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

写锁比读锁有更高的优先级。

InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时可以执行锁定，锁只有在提交或回滚的时候才会释放，并且所有的锁是在同一时刻被释放。

#### 性能优化

性能：完成某件任务所需要的时间度量，换句话说，性能即响应时间。

无法测量就无法有效地优化，所以第一步应该测量时间花在什么地方。

完成一项任务所需时间可以分为两部分：执行时间和等待时间。如果要优化任务的执行时间，最好地方法是通过测量定位不同的子任务花费的时间，然后优化去掉一些子任务、降低子任务的执行频率或者提升子任务的效率。而优化任务的等待时间则要复杂一些，因为等待可能是由其他系统间接影响导致，任务之间也可能由于争用磁盘或CPU资源而相互影响。根据时间是花在执行还是等待上的不同，诊断也需要不同的工具和技术。

性能剖析是测量和分析时间花费在哪里的主要方法。性能剖析一般有两个步骤：测量任务所花费的时间；然后对结果进行统计和排序，将重要的任务排到前面。



可以剖析整个数据库服务器，这样可以分析出哪些查询时主要的压力来源。定位到具体需要优化的查询之后，也可以钻取下去对这些查询进行单独的剖析，分析哪些子任务是响应时间的主要消耗者。



#### 慢查询日志

慢查询日志是开销最低、精度最高的检测查询时间的工具。

可以在MySQL启动时设定一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。该阈值可以通过`long_aquery_time`来设置，默认10秒。

还可以通过`log_queries_not_using_indexes`设置将没有使用索引的SQL语句记录到慢查询日志。

可以通过`mysqldumpslow`将慢查询日志记录dump到文件。

### performance_schema

performance_schema是MySQL内置的一个数据库，主要用于收集数据库服务器性能参数。

几类重要的表：

1. Wait Even表：记录了线程等待的事件；
2. Stage Event表：记录了SQL在每个阶段耗时；
3. Statement Event表：记录了SQL的执行情况。



#### 剖析单条查询

在定位到需要优化的单条查询后，可以针对此查询“钻取”更多的信息，确认为什么会花费这么长的时间执行，以及需要如何去优化。

比如如果查看到查询花了大半时间在将数据复制到临时表这一步，那么就要考虑如何改写查询以避免使用临时表，或提升临时表的使用效率。



#### MySQL Explain

可以使用`explain`来查看SQL语句的执行计划，查看该SQL有没有用上索引，有没有做全表扫描。

```sql
explain select * from emp where name='Tom';
```

结果：

+ id：id越大，执行优先级越高
+ select_type：查询类型
  + simple：简单查询，不包含子查询和union
  + primary：复合查询中的最外层查询
  + subquery：包含在select中的子查询
  + derived：包含在from中的子查询
  + union：在union中的第二个和随后的查询
  + union result：从union临时表检索结果的select
+ table：正在访问哪张表
+ type：关联类型或访问类型，即MySQL决定如何查找表中的行，从优到差：
  + NULL：MySQL能够在优化阶段分解查询语句，在执行阶段不用再访问表或索引。例如在索引列选取最小值
  + const，system：能对查询的某部分进行优化，并将其转化成一个常量。用于primary key或unique key的所有列与常数比较时，最多匹配一行，读取一次，速度较快。system是const的特例，当表中只有一行时。
  + eq_ref：primary key或unique key索引的所有部分被连接使用，最多只会返回一条符合条件的记录
  + ref：相比eq_ref，不使用主键索引或唯一索引，而是使用普通索引或唯一索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行
  + range：范围扫描，通常出现在in，between，>，<，>=等操作中，使用索引来检索给定的范围的行
  + index和ALL一样，不同的是只需扫描索引树，通常比ALL快一点
  + ALL：全表扫描
+ possible_keys：可能使用的索引，不一定使用
+ key：实际使用的索引
+ key_len：索引中使用的字节数
+ ref：表查找所用到的列或常量，常见const（常量）或列名
+ rows：估算出要读取并检测的行数
+ Extra：查询的额外信息
  + Using index：索引覆盖了要查找的列
  + Using where：使用了索引但索引未覆盖要查找的列
  + Using temporary：要创建临时表，需要用索引优化
  + Using filesort：使用了外部排序

explain只能解释select操作。



#### 优化

+ 确认是否在检索大量超过需要的数据，这通常意味着访问了太多的行，但有时候可能访问了太多的列。如可能只需要查询记录的前10条，可加上limit。尽量不使用select *。
+ 确认是否扫描了额外的记录，理想情况下扫描的行数跟返回的行数应该是相同的。可通过建立索引解决，没有索引的话要扫描全表。
+ MySQL从设计上让连接和断开连接都是很轻量级，在返回一个小的查询结果方面很高效，所以可以将一个复杂查询分解为多个小查询。例如在清除大量数据时，一个大的语句可能要耗费许多资源，阻塞其他查询，这时可以做查询切分。
+ 分解关联查询，可以充分利用缓存；可以减少锁的竞争；在应用层做关联，可以更容易对数据库进行拆分，做到高性能和可扩展。



#### 分页优化

