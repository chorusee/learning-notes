### 零散的问题

#### 如何防止重复提交

重复提交是指前端用户在间隔很短的时间周期内对同一个URL发起多次请求，导致在很短的时间内将一份同样的数据多次提交到后端，最终数据库中出现了多条主键ID不一样而其他业务数据几乎一摸一样的记录。

如果多次请求的时间间隔足够短，其过程可以归为“多线程并发导致的并发安全问题”。

只有POST/PUT/DELETE的请求才会造成严重后果，GET请求时具有幂等性的。

1. 前端拦截，比如在用户点完“提交”按钮后，把按钮设置为不可用状态。

   这种方式容易绕过，通过模拟请求来重复提交。

2. 利用Session防止表单重复提交

   服务器返回表单页面时，生成一个token保存于session，并把该session传给表单页面，当表单提交时会带上这个token。

   服务器的拦截器会判断该表单中的token与session中的是否一致，若不一致或session中的token为空则不通过。

   首次提交时表单中的token与session中的token一致，正常通过，然后删除session中的token。当再次提交表单时，由于session中的token为空则不通过。

3. 还可以在服务器缓存提交记录，最简单的是使用Map，key为接口标识（如url）+ 用户标识，值为提交时间。为防止并发问题，使用`ConcurrentHashMap`。

   第一次提交时缓存中并无该用户该类提交的数据，能正常处理。将该次提交记录。

   第二次提交时缓存中已有数据，检查两次提交的时间间隔，如小于某个值（如5秒），则表明是重复提交，拒绝执行后续的业务。

   缓存的数据会越积越多，要定时清理。

#### Java新特性

1. Java 8

   + Lambda和函数式接口：函数是接口就是仅有一个抽象方法的接口，可隐式转换为Lambda表达式。
   + 接口的默认方法和静态方法：接口使用`default`关键字定义方法的默认实现；接口中可以实现静态方法。

   + 方法引用：通过方法引用，可以直接使用方法的名字来指定一个方法，使用方式是

     `类名或对象名::方法名`

   + 重复注解：注解可以摞一块

   + `Optional`：`Optional`是一个可以保存null的容器，通过`isPresent()`检测是否存在，通过`get()`方法返回对象。

   + Stream API：新增了一种系的数据处理方式，这种方式将元素集合看作一种流，在管道中传输，经过一系列处理节点，最终输出结果。

   + 新的日期和时间API：`LocalDate`，`LocalTIme`，`LocalDateTime`，`ZoneDateTime`等

2. Java 9

   + Jigsaw模块系统
   + 改进`try-with-resources`
   + 新增HTTP2 Client

3. Java 10

   + 新增局部类型推断`var`：不需要声明局部变量的类型了

4. Java 11

   + Lambda中使用`var`
   + 字符串API增强：新增了一系列字符串处理方法
   + 标准化HttpClient API
   + Java直接编译运行，省去了先`javac`生成字节码文件再运行的步骤

5. Java 12

   + switch表达式：switch不仅可以作为语句，还能作为表达式了

#### Linux文件权限

文件的权限针对三类对象进行定义：

+ owner 属主，缩写u
+ group 属组，缩写g
+ other 其他，缩写o

每个文件针对每类访问者定义了三种主要权限：

+ r：读
+ w：写
+ x：执行

针对文件和目录来说，r，w，x有不同的含义：

|      | r                    | w                      | x                                                        |
| ---- | -------------------- | ---------------------- | -------------------------------------------------------- |
| 文件 | 读取文件内容         | 修改文件               | 执行                                                     |
| 目录 | 查看目录下的文件列表 | 删除和创建目录下的文件 | 能进入目录，查看目录中文件的详细属性，访问目录下文件内容 |

用不同的值来表示不同的权限：

+ r：4
+ w：2
+ x：1

修改文件权限：

+ `chmod [-cfvR] [--help] [--version] mode file`
+ `chmod xxx file`



#### 使用Git进行项目版本管理

1. master分支

   存放的因该是随时可供生产环境部署的代码。当开发告一段落，产生了一份可供部署的代码时，master分支上的代码会被更新，同时每一次更新都有对应的版本号标签。

   该分支由管理员负责维护，其他人只有拉取的权限。

   生命周期：伴随整个项目的生命周期，随项目结束而结束。

2. develop分支

   develop分支时每次迭代版本的共有开发分支，从最新的master分支派生。

   当develop分支已经实现了软件需求说明书中的所有功能后，派生出release分支。

   该分支由开发人员再各自的feature分支开发完成之后，合并至该分支。

   生命周期：一个阶段功能开发开始到本阶段结束。

3. release分支

   从develop分支派生。

   测试中出现的bug，统一在该分支下进行修改，修改完合并回develop分支和master分支。

   生命周期：一个阶段功能开发结束开始，完成阶段功能测试并修复所有bug，合并回develop分支结束。

4. feature分支

   在开发一项新的软件功的时候使用，从develop分支上拉取，这个分支上的代码变更最终合并回develop分支。

   生命周期：开发一个新功能开始，到完成新功能开发并合并回develop分支结束。

5. hotfix分支

   在master分支发现bug时，在master分支上派生出一个hotfix分支，修改完毕之后，合并至master分支和develop分支，合并完成后删除该分支。

   生命周期：发现master分支bug开始，完成修复master分支bug结束。

#### Ciookie与Session

由于Http协议是无状态的，所以服务端想要记录用户的状态就需要某种机制来识别具体的用户。Cookie和Session就是这样的机制，用来弥补Http协议无状态的不足。

1. 要识别用户和记录用户状态，如何实现？可以给客户端颁发一个通行证，无论谁访问都必须带上自己的通行证，这样客户端就能通过通行证确认客户身份了。这就是Cookie的工作原理。

   Cookie实际上是一小段的文本。服务器向客户端颁发一个Cookie，客户端浏览器将这个Cookie保存起来。

   当浏览器再次请求该网站的时候，浏览器就把Cookie一同提交给服务器。服务器根据Cookie识别用户。

   Cookie不可跨域名。根据Cookie规范，Cookie是由浏览器来管理的，浏览器会根据域名来保证不同的网站只会携带属于这个网站的Cookie。

   Cookie的常用属性：

   + String name： Cookie的名称，一旦创建便不可更改
   + Object value： Cookie的值，如果为Unicode字符，需要编码。
   + int maxAge： Cookie的失效时间，单位为秒。若为负数，则关闭浏览器即失效；若为0，表示删除该Cookie。
   + String domain：域名

2. Session应该是一种抽象概念，有多种不同的Session实现

   例如Python的Flask框架实现Session是将Session加密后放在Cookie里。

   Java实现Session是将Session存放在服务器上，在Cookie上存一个JSessionId，每次客户端访问就根据JSessionId找到对应的Session。

   为防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除，这个就是Session超时时间。

   JSessionId生存时间设置为-1，关闭浏览器即失效，所以此时Session也不可用了。

   Session的生命周期从开始访问开始，关闭浏览器结束，或者Session过期。

#### JIT（Just In Time Compiler）

JIT一般翻译为即时编译器。当虚拟机发现某个方法或代码块执行的特别频繁，就会把这些代码认定为热点代码（Hot Spot Code），为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各层优化。完成这项任务的正是JIT。

对于Java代码，一般是编译成字节码文件，然后由JVM解释执行，所以可以说Java是一种半编译半解释型语言。

当JIT启用时，JVM堵路class文件解释后，将其发给JIT，JIT编译器将字节码编译成与机器代码。经过JIT编译过的代码会被保存起来，以备下次使用。因此从理论上说，采用JIT技术能够接近纯编译的语言。

判定热点代码的方式：

+ 基于采样的热点探测

  虚拟机会周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那么个方法就是热点代码。这种探测方法实现简单高效，缺点时难以精确地确认一个方法地热度，因为容易受到线程阻塞或别的外界因素影响而扰乱热点探测。

+ 基于计数器的热点探测

  采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法执行次数，如果执行次数超过一定阈值，就认为是热点方法。这种统计方法实现复杂一点，需要为每个方法建立并维护计数器，但它的统计结果相对严谨。

  HotSpot采用的是这种方法。