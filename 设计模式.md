### 设计模式

#### OOP七大原则

+ 开闭原则：对扩展开放，对修改关闭
+ 里氏替换原则：继承必须确保超类所拥有的性质在子类中任然成立
+ 依赖倒置原则：要面向接口编程，不要面向实现编程
+ 单一职责原则：控制类的粒度大小，将对象解耦，提高内聚性
+ 接口隔离原则：要为各个类建立它们需要的专用接口
+ 迪米特法则：至于你的直接朋友交谈，不要跟“陌生人”说话
+ 合成复用原则：尽量先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现

#### 分类

+ 创建型模式

  单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式

+ 结构型模式

  从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题。

  适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式

+ 行为型模式

  模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式

#### 单例模式

饿汉式单例：

```java
public class Hungry {
    // 私有构造方法
    private Hungry() {}
    
    private final static HUNGRY = new Hungry();
    
    public static Hungry getInstance() {
        return HUNGRY;
    }
}
```

懒汉式单例：

```java
public class LazyMan {
    private LazyMan() {}
    
    // volatile 关键字禁止指令重排
    private volatile static LazyMan lazyMan;
    
    // 双重检测锁模式的 懒汉式单例 DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();
                }
            }
        }
        return lazyMan;
    }
}
```

#### 工厂模式

作用：实现了创建者和调用者分离

核心本质：

+ 实例化对象不使用new，用工厂方法代替
+ 将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦

三种模式：

+ 简单工厂模式（静态工厂模式）

  增加新的产品，需要修改代码，不满足开闭原则。

  虽然某种程度上不符合设计原则，但实际使用最多

+ 工厂方法模式

  每一种产品都相应的工厂。不修改已有类的前提下，通过增加新的工厂类实现扩展。

+ 抽象工厂模式

  围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。

#### 原型模式

Spring Bean的原型模式



#### 适配器模式

USB转换器。

将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

角色分析：

+ 目标接口：客户期待的接口，目标可以是具体的或抽象的类，也可以是接口。
+ 需要适配的类：需要适配的类或适配者类。
+ 适配器：通过包装一个需要适配的对象，把原装接口转换成目标对象。