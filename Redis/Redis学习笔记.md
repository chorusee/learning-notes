### Redis学习笔记

#### NoSQL概述

NoSQL = Not Only SQL，泛指非关系型数据库

很多类型的信息（社交网络、地理位置等）不需要一个固定的格式，不需要多余的操作就可以横向扩展。

NoSQL特点：

+ 方便扩展（数据之间没有关系，很好扩展）
+ 大数据量性能高（Redis一秒写8万次，读11万次）
+ 数据类型多样（不需要事先设计数据库，随取随用）

RDBMS与NoSQL区别：

+ 传统RDBMS
  - 结构化组织
  - SQL
  - 数据和关系都存在单独的表中
  - 严格的一致性
  - 基础的事务
+ NoSQL
  + 不仅仅是数据
  + 没有固定的查询语言
  + 键值对存储、列存储、文档存储、图形数据库
  + 最终一致性
  + CAP定理和BASE定理
  + 高性能、高可用、高可扩

NoSQL四大分类：

+ K-V键值对：Redis
+ 文档型（BSON格式）：MongoDB（居于分布式文件存储的数据路，主要用来处理大量的文档。是介于关系型和非关系型数据库的中间产品）
+ 列存储数据库
+ 图关系数据库

#### Redis概述

Redis是什么？

Redis（Remote Dictionary Server），即远程字典服务，是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，提供多种语言API。

Redis能干嘛？

1. 内存存储、持久化（RDB、AOF）
2. 效率高，可用于缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器

特性

1. 多样的数据类型
2. 持久化
3. 集群
4. 事务

Redis对比Memecache：

+ Redis是单线程的，而Memecache支持多线程；
+ 对于key-value这样的简单数据，Memcache的内存使用率更高；
+ Redis支持数据持久化和主从复制，而Memcache的数据断电即失；
+ Redis支持更多的数据类型；

Redis有16个数据库，默认使用的是0号，可以使用`select <index>`切换

`dbsize` 当前DB中的key数

`keys *`查看所有的key

`flushdb`清除当前DB

`flushall`清除全部数据库



Redis是单线程的

Redis很快，官方表示，Redis是基于内存操作，CPU不是性能瓶颈，Redis的瓶颈是机器内存和网络带宽，既然可以使用单线程实现，而多线程很麻烦，所以就使用单线程。

为什么单线程还那么快？

Redis是C语言写的，官方提供的数据为100000+的QPS完全不比同样使用Key-Value的Memecache差。

+ 误区一：高性能一定是多线程
+ 误区二：多线程一定比单线程效率高

Redis将所有数据都存放在内存中，不存在等待IO CPU长时间空闲的状态。多线程CPU上下文会切换，这比较耗时。对于内存系统来说，如果没有上下文切换效率就是最高，多次读写在一个CPU上，就是最佳方案。

将数据存放在磁盘中（MySQL），当从磁盘中读取数据时，CPU会空转，这时将CPU交给其他线程使用，将会提高性能。

#### 基本命令

`keys *`

`set`

`get`

`move`

`exists`

`expire`

`ttl`查看key的剩余时间

`type`查看key的类型



#### 五大基本数据类型

##### String 字符串

`append` 往String后追加，如果key不存在，相当于set

`strlen` 获取key的长度

`incr` 自增一

`decr` 自减一

`incrby key step` 可设置步长，指定增量

`getrange key start end` 截取子字符串（包括end，-1表示全部）

`setrange key index xx` 替换指定位置的字符串

`setex(set with expire)` 设置key同时设置过期时间

`setnx(set if not exist)`当不存在时设置（在分布式锁中常使用）

`mset` 同时设置多个值

`mget`同时获取多个值

`msetnx` msetnx是一个原子操作，可以用`mset user:{id}:field`来设置对象

`getset key value` 如果不存在值，返回nil；如果存在值，返回原来的值，并设置新的值

###### String使用场景：value除了字符串还能是数字

+ 计数器
+ 统计多单位的数量（播放量、点击量）
+ 对象缓存

##### List 列表

可以把List用成栈、队列、阻塞队列

List的所有从左边操作的命令都是`L`开头的，右边操作的`R`开头

`LPUSH`

`LRANGE`

`RPUSH`

`RRANGE`

`LPOP`

`RPOP`

`LINDEX` 通过index获得list中某一个值

`RINDEX`

`LLEN`

`LREM <count> <value>` 从list中移除count个value值

`LTRIM` 通过下标截取指定的长度，list被改变

`RPOPLPUSH <list1> <list2>` 移除右边最后一个元素，移到新的列表

`LSET <list> <index> <item>` 设置index位置的值，更新操作。index位置不存在会报错

`LINSERT <list> before/after <value> <other>` 将某一个值插入到列表中某个元素的前面或后面

小结：

+ 实际上是一个链表

+ 如果key不存在，创建新的链表

+ key存在，新增内容

+ 如果移除了所有值，空链表，也代表不存在

+ 在两边插入或改动值，效率最高；中间元素，效率低一点

##### Set

Set中的元素不能重复。

`sadd` 添加值

`smembers` 查看指定set

`sismember <set> <value>` 判断某个值是否在集合中

`scard` 查看元素个数

`srem` 移除集合中指定元素

`srandmember` 随机抽选出一个元素

`srandmember <num>` 随机抽选出num个元素

`spop` 随机移除集合中的元素

`smove <src> <des> <value>` 将一个指定的值移到另一个集合

`sdiff` 差集

`sinter` 交集

`sunion` 并集

##### Zset 有序集合

在set的基础上，增加了一个值score

`zadd myset 1 one 2 two`

`zrangebyscore -inf +inf` 按score从小到大排序

`zrevrangebyscore`  降序排序

`zrangebyscore -inf +inf withscore` 输出带上score

`zrem` 移除元素

`zcard` 获取元素个数

`zcount myset 1 3` 指定区间的成员数量

##### Hash

key - map 集合。值是map集合。本质和String类型没太大区别，还是一个简单的key - value。

`hset myhash field1 abc` 设置一个值

`hget myhash filed1` 获取一个值

`hmset myhash field1 abc field2 def` 设置多个值

`hmget myhas` 获取多个值

`hdel myhash field1` 删除指定的key

`hlen myhash` 获取长度

`hgetall` 获取全部

`hexists myhash field1` 判断指定字段是否存在

`hkeys myhash` 获取所有key

`hvals myhash` 获得所有value

`hincrby`

`hdecrby`

`hsetnx`

#### 三种特殊数据类型

##### Geo

##### HyperLogLog

##### Bitmap



#### 事务

Redis单条命令保证原子性，但事务不保证原子性。

Redis事务没有隔离级别的概念。

所有的命令在事务中，没有直接被执行，只有发起执行命令的时候才会执行。

Redis事务的本质：一组命令的集合，一个事务中所有的命令都会被序列化，在事务执行过程中，会按顺序执行。一次性、顺序性、排他性。

过程：

1. 开启事务（`multi`）
2. 命令入队
3. 执行事务（`exec`）

取消事务：`discard`

编译型异常：事务中所有的命令都不会执行

运行时异常：如果事务队列中存在语法错误，那么执行命令的时候其他命令可以正常执行，错误命令抛出异常。（即保证都执行成功，原子性不满足）



悲观锁：一个线程修改某个数据的时候，悲观地认为肯定会有其他线程也进行修改，所以直接独占，等修改完了再让其他线程抢占。这种锁性能不好，不适合对并发性要求高的场景。

乐观锁：一个线程在修改某个数据的时候，乐观地认为不会有其他线程进行修改，直接修改该数据，然后在提交的时候检查一下是否有其他线程修改过原来的数据，如果修改过，那么就放弃这次修改，返回失败或重试。这种比较宽松的加锁机制，性能显然好一些。

监视对象：`watch key`

使用`watch`可以当作乐观锁操作。



#### Redis持久化

Redis是内存数据库，如果不能将内存中的数据保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。

#### RDB（Redis DataBase）

在指定的时间间隔内将内存中的数据集快照写入磁盘，恢复时直接将快照文件直接读入到内存里。

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时RDB文件中，待持久化过程都结束了，再用这个临时文件替换原来的RDB文件。整个过程中，主进程是不进行任何IO操作且依然可以接受客户端的命令。这就确保了极高的性能。如果需要进行大规模数据恢复，且对于数据恢复完整性不是非常敏感，那RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。

触发机制：

1. save规则满足
2. 执行flushall
3. 退出Redis

如何恢复RDB？

只需要将rdb文件放到Redis启动目录就可以，Redis启动时会自动检查dump.rdb恢复其中的数据。

`config get dir`命令查看路径

优点：

+ 适合大规模的数据恢复
+ 对数据完整性要求不高

缺点：

+ 一定的时间间隔执行保存操作，如果Redis意外宕机，最后一次保存之后的修改数据就没有了
+ fork进程时，会占用一定的内存空间

#### AOF（Append Only File）

将我们所有的命令都记录下来，恢复时所有的操作都执行一遍。

以日志的形式来记录每个操作，将Redis执行过的所有写指令记录下来，只许追加到文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据。换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复。

默认不开启，需要手动配置`appendonly yes`

如果aof文件有错误，Redis启动不起来，需要修复这个aof文件。

`redis-check-aof --fix appendonly.aof`

若AOF文件太大了，Redis会执行重写，使用最少的命令代替原来的命令（如用一条set命令代替100条incr命令）。重写期间，原来的AOF文件任然存在，因此保证了重写失败也不会损失数据。

优点：

+ 每一次修改都同步，文件完整性更加好
+ 每秒同步一次，可能会丢失一秒的数据
+ 从不同步，效率最高

缺点：

+ 相对于数据文件来说，aof远大于rdb，修复也比rdb慢
+ aof运行也比rdb慢 



#### Redis发布订阅

```bash
# 订阅一个或多个频道的信息
subscribe channel [channel ...]

# 将信息发送到指定的频道
publish channel message

# 订阅一个或多个符合给定模式的频道
psubscribe pattern [pattern ...]
```



#### Redis主从复制

主从复制的主要作用：

1. 数据冗余
2. 故障恢复
3. 负载均衡
4. 高可用（集群）的基石

环境配置：只需要配置从库，不需要配置主库。

`info replication` 查看当前库信息

`slaveof 127.0.0.1 6379` 配置master，通过命令配置

通过配置文件 `replicaof master`配置



主机负责写，从机不能写只能读。主机中所用的信息都会被从机保存

复制原理：

slave启动成功连接到master后会发送一个psync同步请求

master接到请求，启动后台的存盘进程，同时收集所有接收到的用于修改数据集的命令。在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。

+ 全量复制：slave收到数据库文件之后，将其存盘并加载到内存中

  全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：

  1. 从服务器连接主服务器，发送PSYNC命令；
  2. 主服务器接收到PSYNC命令之后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；
  3. 主服务器BGSAVE执行完毕之后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
  4. 从服务器接收到快照文件后丢弃所有的旧数据，载入收到的快照；
  5. 主服务器快照发送完毕之后开始向从服务器发送缓冲区中的写命令；
  6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令。

+ 增量复制：master继续将新的所收集到的修改命令依次传给slave，完成同步。

  主服务器和从服务器分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。偏移量用于判断主从节点数据库状态是否一致，offset不同则不一致。主节点维护一个固定长度的先进先出的队列，称为复制积压缓冲区。由于复制积压缓冲区的大小固定且先进先出，时间较早的写命令会被挤出缓冲区。当主从节点offset过大超出挤压缓冲区长度时，无法执行增量复制，只能执行全量复制。

  每个节点（无论主从）在启动时都会生成一个随机的`runid`，用来标识一个Redis节点。主从节点初次复制时，主节点将自己的`runid`发送给从节点，从节点保存起来；当断线重连时，从节点将这个`runid`发送给主节点，主节点根据这个`runid`来判断是否进行增量复制：

  + 如果从节点保存的`runid`与主节点的`runid`相同，说明之前同步过，主节点尝试使用增量复制，具体是否进行增量复制还要看offset和复制积压缓冲区的情况。
  + 不同则进行全量复制。

但只要是重新连接master，一次完全同步（全量复制）将被自动执行，数据一定可以从从机上看到。

#### 哨兵模式

传统的主从切换方式是当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。

哨兵模式是一种特殊的模式，哨兵是一个独立的进程，独立运行。哨兵有两个作用：

+ 通过发送ping命令，作为心跳检测，判断Redis节点是否存活
+ 当哨兵监测到master宕机，会自动将一个slave切换为master，然后通过订阅发布模式通知其他从节点，修改配置，切换主机

然而一个哨兵对Redis节点进行监控，这个哨兵本身也可能不可用，为此，可设置多个哨兵组成集群，各个哨兵之间也会进行监控。

故障切换（failover）：

假设主节点宕机，哨兵1先检测到这个情况，系统不会马上进行切换，仅仅哨兵1主观认为主服务器不可用，这个现象称为**主观下线**。如果后面的哨兵也检测到主服务器不可用并且数量达到一定值时，那么哨兵就会进行一次投票，投票的结果由一个哨兵的Leader发起，进行failover操作。切换成功之后，就会通过订阅发布模式，让各个从节点切换主机，这个过程称为**客观下线**。

sentinel.conf文件：

```bash
# mymaster为主节点名，可自定义；2表示当2个以上的哨兵认为主节点不可用时才进行failover操作
sentinel monitor mymaster 192.168.11.128 6379 2
```

连接哨兵集群：

```java
public class TestSentinels {
    @SuppressWarnings("resource")
    @Test
    public void testSentinel() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        jedisPoolConfig.setMaxTotal(10);
        jedisPoolConfig.setMaxIdle(5);
        jedisPoolConfig.setMinIdle(5);
        // 哨兵信息
        Set<String> sentinels = new HashSet<>(Arrays.asList("192.168.11.128:26379",
                "192.168.11.129:26379","192.168.11.130:26379"));
        // 创建连接池
        JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinels,jedisPoolConfig,"123456");
        // 获取客户端
        Jedis jedis = pool.getResource();
        // 执行两个命令
        jedis.set("mykey", "myvalue");
        String value = jedis.get("mykey");
        System.out.println(value);
    }
}
```



#### Redis缓存穿透和雪崩

##### 缓存穿透（查不到）

用户想要查询一个数据，发现Redis中没有，也就是缓存没有命中，于是向持久层数据库查询，发现数据库中也没有，于是查询失败。当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就出现了缓存穿透。

解决方案：

1. 布隆过滤器

   布隆过滤器是一种数据结构，对所有可能查询的参数都以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。

   但布隆过滤器存在误判地可能。

   > 布隆过滤器
   >
   > 布隆过滤器是一个长度为n的比特数组，我们要将一个key映射到这个数组，需要k个哈希函数。如n=8，k=3，将key1应用这3个哈希函数得到3个值1，4，7，就将下标1，4，7的位置置为1；key2应用这个函数得到3，4，8，将这3个位置置为1，其中下标为4的已经是1了。查询某个key是否存在时，将这个key应用这3个哈希函数，然后判断结果的位置是否为1。

2. 缓存空对象

   当存储层不命中后，即使返回的空对象也将其缓存起来，同时设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。

   但这种方法存在两个问题：

   + 如果空值被缓存起来，这就意味着需要更多的空间存储更多的键，因为当中可能会有很多的空值的键
   + 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响

##### 缓存击穿（量太大，缓存过期）

注意和缓存穿透的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

当某个key过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据并写回缓存，会导致数据库瞬间压力过大。

解决方案：

1. 设置热点数据永不过期

2. 加互斥锁

   使用分布式锁，保证对每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

##### 缓存雪崩

在某一个时间段，缓存集中过期，或Redis宕机，或服务开启的时候，缓存中不存在数据，同时有大量请求到来。这些请求会直接到达数据库。

解决方案：

1. Redis高可用，搭建Redis的集群

2. 限流降级

   在缓存失效后，通过加锁或队列来控制读数据库写缓存的线程数量。

3. 数据预热

   在正式部署前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。
   
4. 设置不同的过期时间，让缓存失效的时间点尽量均匀。

#### Redis通信协议

Redis客户端和服务器之间采用的通信协议是RESP（REdis Serialization Protocol），传输层使用TCP。特点：

+ 实现容易
+ 解析快
+ 人类可读

#### Redis过期删除策略

Redis提供四个命令来设置过期时间：

+ EXPIRE <key> <ttl>：将键的生存时间设置为ttl秒
+ PEXPIRE <key> <ttl>：将键的生存时间设置为ttl毫秒
+ EXPIREAT <key> <timestamp>：将键的生存时间设置为timestamp指定的秒数时间戳
+ PEXPIREAT <key> <timestamp>：将键的生存时间设置为timestamp指定的毫秒数时间戳

过期时间判定：Redis的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典。这个字典的键是一个指针，指向键空间中的某个键对象；字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的时间戳。

当客户端执行PEXPIREAT命令时，为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。

PERSIST命令可以移除一个键的过期时间。

有三种不同的删除策略：

1. 定时删除：在设置键的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除。

   优点：保证尽可能快地删除过期键，并释放过期键所占用地内存，对内存最友好。

   缺点：对CPU时间不太友好，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间。另外创建一个定时器要用到时间事件，而查找一个时间事件的时间复杂度是O(n)

2. 惰性删除：放任键过期不管，但每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，否则返回该键。

   优点：对CPU时间友好，只有在非做不可的时候才删除过期键，并且删除的目标仅限于当前处理的键。

   缺点：对内存不友好。并且如果有非常多的过期键，且这些过期键又恰好没被访问的话，它们也许永远不会被删除，有内存泄漏的危险。

3. 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，由算法决定。

   定期删除策略是前面两种策略的一种整合和折衷。

   定期删除策略的难点是确定删除操作执行的时长和频率：

   如果删除操作执行地太频繁，或者执行时间太长，定期删除策略就会退化成定时删除策略；

   如果执行得太少，或执行时间太短，定期删除优惠和惰性删除一样。

Redis配合使用惰性删除和定期删除两种策略。

内存淘汰策略：

1. 利用LRU算法移除设置过过期时间的key
2. 利用LRU算法移除任何key
3. 随机移除设置过过期时间的key
4. 无差别的随机移除
5. 移除即将过期的key
6. 不移除任何的key，只返回一个写错误

#### Redis Cluster

为什么要实现Redis Cluster？

+ 随着用户数增多，并发越来越高，业务需要更高的QPS，而主从复制中单机的QPS不能满足需求
+ 随着数据量增大，现有服务器内存不能满足业务需要
+ 业务的流量已经超过服务器的网卡上限，需要使用分布式来分流

Redis Cluster采用无中心结构，每个节点保存数据，每个节点都与其他所有节点相连。

![img](https://upload-images.jianshu.io/upload_images/12185313-0f55e1cc574cae70.png?imageMogr2/auto-orient/strip|imageView2/2/w/275/format/webp)

结构特点：

+ 所有节点都是平等的，所有节点都彼此互联，节点间使用Gossip协议通信
+ 节点的fail是超过集群中半数的节点检测失败时才生效
+ 客户端不需要连接集群所有的节点，连接集群中任何一个可用节点即可
+ 集群数据分片分为16384个 槽（slot），然后每个节点负责管理一部分槽的读写操作，每个键值对具体存储在哪个槽根据CRC16(key) mod 16384的值来决定。

当客户端向任一节点发送读写操作时，若该节点经过计算发现不属于自己负责的槽位，就会将实际所属的节点以及槽位信息返回给客户端，客户端接着自动将原请求发往这个节点。

节点扩容：

整个方案有两个映射表：

+ 键值对-槽位映射
+ 槽位-节点映射

槽位固定16384个，不管节点怎样改变都不会影响每个key值计算出来的槽位。所以如果有节点加入或退出，只需要把原节点的部分槽位的数据迁移到新节点上，并更新槽位-节点映射表就可以了。

Redis Cluster为保证数据高可用，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据的存取服务，从节点则从主节点拉取数据备份。当主节点宕机集群会将一个从节点升级为主节点。

Redis Cluster的搭建：

1. 修改Redis配置文件：

   ```
   daemonize yes # 后台运行
   port 7001 # 端口
   cluster-enable yes # 开启Redis Cluster
   cluster-config-file nodes.conf # cluster配置文件，自动生成
   cluster-node-timeout 15000 # 节点通信超时时间
   ```

2. 创建集群：

   ```
   redis-cli --cluster create [ip:port ...] --cluster-replicas 1
   ```

   
