### Zookeeper学习笔记

Zookeeper是一个基于观察者模式的分布式服务管理框架，它负责存储和管理重要的数据，并接受观察者的注册，一旦这些被观察的数据状态发生改变，Zookeeper就负责通知已经在Zookeeper上注册的那些观察者让它们做出相应的反应。

> 观察者模式
>
> 指多个对象存在一对多的一赖关系，当一个对象状态发生改变时，所有依赖它的对象都得到通知并被自动更新。这种模式又被称作发布-订阅模式，它是行为型模式。
>
> 实现观察者模式时要注意具体目标对象和具体观察者之间不能直接调用，否则将使两者之间紧密耦合起来。
>
> 优点：
>
> 1. 降低了目标和观察者之间的耦合关系
> 2. 目标和观察者之间建立了一套触发机制
>
> 缺点：
>
> 1. 目标与观察者之间的依赖关系并没有完全解除，可能出现循环引用
> 2. 当观察者很多时，通知的发布会花费很多时间

简单概括：Zookeeper = 文件系统 + 通知机制

#### Zookeeper干吗用的？

为大型分布式计算提供分布式配置服务、同步服务、命名注册、分布式锁。

#### Zookeeper数据结构

Zookeeper提供的命名空间非常类似于标准文件系统，key-value形式存储。名称key由`/`分割的一系列路径元素，Zookeeper名称空间的每个节点都是一个路径标识。

![img](https://www.runoob.com/wp-content/uploads/2020/09/zknamespace.jpg)

#### CAP理论

+ 一致性：在分布式系统中，一致性是指数据在多个副本之间是否能够保持一致的特性。
+ 可用性：每次请求都能获取到正确的响应，但不保证获取的数据为最新数据。
+ 分区容错性：分布式系统在遇到任何网络分区故障时，任然能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。

一个分布式系统最多只能满足CAP三项中的两项。

P是必须的，因此只能在CP和AP中选择，Zookeeper保证的是CP，对比Spring Cloud中的注册中心Eureka实现的是AP。

![img](https://www.runoob.com/wp-content/uploads/2020/09/cap-theorem-diagram.png)

#### BASE理论

BASE是Basically Available（基本可用）、Soft-state（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。

+ 基本可用：在分布式系统出现故障时，允许损失部分可用性
+ 软状态：允许分布式系统出现中间状态，而且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。
+ 最终一致性：data replications 经过一段时间达到一致性。

BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。

#### 数据模型

Zookeeper中的所有存储的数据都是由`znode`组成的，即节点，以key-value的形式存储数据。整体结构类似于Linux文件系统的模式，以树形结构存储。其中根路径以`/`开头。

| cZxid          | 创建节点时的事务ID                                           |
| :------------- | :----------------------------------------------------------- |
| ctime          | 创建节点时的时间                                             |
| mZxid          | 最后修改节点时的事务ID                                       |
| mtime          | 最后修改节点时的时间                                         |
| pZxid          | 表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID**（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid）** |
| cversion       | 子节点版本号，子节点每次修改版本号加1                        |
| dataversion    | 数据版本号，数据每次修改该版本号加1                          |
| aclversion     | 权限版本号，权限每次修改该版本号加1                          |
| ephemeralOwner | 创建该临时节点的会话的sessionID。（**如果该节点是持久节点，那么这个属性值为0**） |
| dataLength     | 该节点的数据长度                                             |
| numChildren    | 该节点拥有子节点的数量**（只统计直接子节点的数量）**         |

#### 客户端基础命令

+ ls 命令：用于查看某个路径下目录列表（类比Linux的ls命令）

+ ls2 命令：用于查看某个路径下目录列表，他比ls命令列出更多的详细信息（对比ll命令）

+ get 命令：用于获取节点数据和状态信息

  `get path [watch]`

  [watch] 对节点进行事件监控

+ set 命令：用于修改节点存储的数据

  `set path data [version]`

  [version] 为版本号，可用作乐观锁

+ stat 命令：用于查看节点状态信息

+ create 命令：用于创建节点并赋值

  `create [-s] [-e] path data acl`

  + -s 代表顺序节点，-e 代表临时节点，临时节点不能再创建子结点
  + path：指定要创建节点的路径
  + data：要在此节点存储的数据
  + acl：访问权限相关

+ delete 命令：用于删除某节点

#### Zookeeper特点

+ Zookeeper是存在一个Leader和多个Follower组成的集群
+ 集群中若存在半数以上节点存活，就能正常工作
+ 数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪一个Server获取的数据都是一样的
+ 更新请求按发送的顺序依次执行
+ 数据更新是原子性的
+ 实时性：Client能够读取到最新的数据

#### Zookeeper写流程

1. 客户端连接到集群中某一个节点，发送一个写请求
2. 如果连接的不是leader，则该节点将写请求转发给leader
3. leader发起一个提议，各节点参加投票
4. 只有当超过半数的节点同意该提议，返回写成功后，才认为这个写操作成功了，然后leader将通知最开始的节点写数据成功
5. 客户端连接的节点返回写数据成功给客户端

#### 节点类型

+ 持久化节点
+ 持久化顺序编号的节点
+ 临时节点：客户端与Zookeeper断开连接后，该节点被删除
+ 临时编号节点

#### 节点特性

1. 同一级节点key是唯一的
2. 创建节点时，必须要带上全路径
3. session关闭，临时节点清除
4. 有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。
5. watch机制，客户端注册它关心的目录节点，当节点发生变化（数据改变、删除、子节点增加或删除）时，Zookeeper会通知客户端。
6. delete命令只能一层一层删除

#### 选举机制

Zookeeper选举存在两个阶段：服务启动时和运行过程中leader宕机。

几个重要参数：

+ 服务器ID（myid）：编号越大在选举中权重越大
+ 事务ID（zxid）：值越大说明数据越新，权重越大。Zookeeper的状态每一次改变，都对应一个递增的事务id称为zxid。由于zxid的递增性质，如果zxid1小于zxid2，则说明zxid1先于zxid2.创建任意节点，删除任意节点或更新任意节点数据都会导致Zookeeper状态改变。
+ 逻辑时钟：同一轮投票过程中的逻辑时钟是相同的，每次投完一次值会增加

**选举状态：**

- LOOKING： 竞选状态
- FOLLOWING：随从状态，同步 leader 状态，参与投票
- OBSERVING：观察状态，同步 leader 状态，不参与投票
- LEADING：领导者状态

##### 选举流程简述

- 在集群初始化阶段，当有一台服务器Server1启动时，其单独无法进行和完成Leader选举，当第二台服务器Server2启动后，此时两台机器可以相互通信，每台机器都试图找到Leader，于是进入Leader选举过程。选举过程如下：

  **(1) 每个Server发出一个投票投给自己**。由于是初始情况，Server1和Server2都会将自己作为Leader服务器来进行投票，**每次投票会包含所推举的服务器的myid和ZXID**，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。

  **(2) 接受来自各个服务器的投票**。集群的每个服务器收到投票后，**首先判断该投票的有效性，如检查是否是本轮投票、是否来自LOOKING状态的服务器**。

  **(3) 处理投票**。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下

  **1、优先检查ZXID。ZXID比较大的服务器优先作为Leader**。

  **2、如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器**。

  对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的ZXID，均为0，再比较myid，此时Server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于Server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。

  **(4) 统计投票**。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于Server1、Server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了Leader。

  **(5) 改变服务器状态**。一旦确定了Leader，每个服务器就会更新自己的状态，如果是Follower，那么就变更为FOLLOWING，如果是Leader，就变更为LEADING。

![img](https://www.runoob.com/wp-content/uploads/2020/09/vote-01.png)

#### Zookeeper实现分布式锁

##### 排他锁

排他锁（Exclusive Locks），又被称为写锁或独占锁，如果事务T1对数据对象O1加上排他锁，那么整个加锁期间，只允许事务T1对O1进行读取和更新操作，其他任何事务都不能进行读或写。

利用 Zookeeper 的同级节点的唯一性特性，在需要获取排他锁时，所有的客户端试图通过调用 create() 接口，在 `/exclusive_lock`节点下创建**临时**子节点 `/exclusive_lock/lock`，最终只有一个客户端能创建成功，那么此客户端就获得了分布式锁。同时，所有没有获取到锁的客户端可以在 `/exclusive_lock` 节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。

##### 共享锁

共享锁（Shared Locks），又称读锁。如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁，直到该数据对象上的所有共享锁都释放。

1. 创建临时顺序节点
2. 调用getChildren接口来获取所有已创建的节点列表
3. 判断是否获得锁，对于读请求如果所有比自己小的子节点都是读请求或者没有比自己序号小的子节点，表明已经成功获取共享锁，同时开始执行读逻辑。对于写请求，如果自己不是序号最小的子节点，那么就进入等待。
4. 如果没有获取到共享锁，读请求向比自己序号小的最后一个写请求节点注册 watcher 监听，写请求向比自己序号小的最后一个节点注册watcher 监听。



#### Zookeeper角色

+ 领导者，负责发起提案，更新系统状态
+ 学习者，包括跟随者和观察者，follower用于接受客户端请求并向客户端返回结果，在选举过程中参与投票；observer可以接受客户端连接，将写请求转发给leader，但observer不参与投票过程，只同步leader状态，observer的目的是为了扩展系统，提高读取速度
+ 客户端，请求发起方

#### 为什么需要观察者？

为了支持更多的客户端，需要更多的节点，但节点增多，投票阶段越费时，影响可用性，因此引入观察者。观察者不投票，接收客户端请求，并将写请求转发给leader。

#### 为什么集群数量是奇数



Zookeeper的核心是原子广播，这个机制保证了各个节点之间的同步。实现这个机制的协议叫做Zab。Zab协议有两种模式，分别是恢复模式和广播模式。当服务启动或者在领导者崩溃后，进入恢复模式，当领导者被选出来，且大多数节点完成了和leader的状态同步后，恢复模式结束。状态同步保证了leader和server具有相同的系统状态。

一旦leader和多数的follower进行了状态同步，它就可以开始广播消息，即进入广播状态。当一个Server加入Zookeeper服务时，它会在恢复模式下启动，发现leader并与之同步。待到同步结束，他也参与广播消息。

广播模式需要保证提案按顺序处理，因此zk采用递增的事务号来保证，所有的提案都在被提出时加上了zxid。

为了保证事务的一致性，Zookeeper采用了递增的事务id（zxid）来标识事务。所有的提议都在被提出的时候加上zxid。实现zxid的是一个64为的数字，高32为用来标识leader是否改变，每一次leader改变都会有新的值，标识当前属于哪个leader的统治时期。低32为用于递增计数。

当leader崩溃，这时候zk进入恢复模式，恢复模式需要重新选举一个新的leader让所有server都恢复到一个正确的状态。

每个Server在工作过程中有三个状态：

+ LOOKING：当前Server不知道leader是谁，正在搜寻
+ LEADING：当前Server既是选举出来的leader
+ FOLLOWING：leader已经选举出来，当前Server与之同步



#### 分布式一致算法：Paxos

ZK每个节点都记录一个当前事务ID，当一个节点要发起提议时，为这个提议加上一个事务ID：当前事务ID + 1，其他的节点收到这个提议，如果提议的事务ID大于自己保存的事务ID，则同意该事务，且该节点会更改它的事务ID为提议的事务ID，否则拒绝。

但有一个问题，比如有三个节点保存的都是3，同时发起自己的提议，加上事务ID为4，并把自己保存的事务ID改为4，当接收到其他节点的提议时候，都拒绝，这样永远都不会有提议成功。

所以限制只有leader才能发起提议，即解决了这个问题。

