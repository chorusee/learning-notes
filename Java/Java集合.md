## Java集合

### Collection接口

#### List

1. ArrayList

   通过数组实现，线程不安全。允许对数据进行随机访问，但是插入、删除操作需要移动大量数据。需要一块连续的内存，当数组已满时再插入新数据，需要将原数组复制到新数组。

   扩容：以原数组长度1.5倍为标准，需要的容量小于这个数，则以1.5倍为新数组的容量，否则以实际需要的长度为容量，复制数组调用了`Arrays.copyOf()`方法，这是一个本地方法。

2. Vector

   数组实现，线程同步安全。访问比ArrayList慢。

3. LinkedList

   链表实现，不需要一整块连续的内存空间，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。

   另外它还提供了一些List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作栈、队列和双向队列用。线程不安全。

#### Set

Set里的数据是无序的，即不能通过索引访问，输入的顺序与存储的顺序不一致。Set中不允许有重复的元素，Set中的元素必须实现hashCode()和equals()方法。

1. HashSet

   通过哈希表实现。线程不安全。

2. TreeSet

   通过红黑树实现。因为插入元素时要进行比较，所以每个元素都要实现Comparable接口并覆写compareTo()函数。通过迭代器遍历时输出的是有序的（按大小排序）。线程不安全。

3. LinkedHashSet

   LinkedHashSet继承自HashSet，又通过双向链表维护元素插入顺序。线程不安全。

### Map接口

#### HashMap

HashMap最多允许一条记录的键为null。线程不安全。

1. Java 7的实现：基于哈希表实现，通过拉链法解决哈希冲突。每个元素都被包装成一个Entry实例，有key、value、hash值和指向下一个节点的 next指针。

   三个重要的域：

   + capacity：当前数组容量，始终保持为2^n，每次扩容变为原来的2倍；
   + loadFactor：负载因子，默认为0.75；
   + threshold：扩容阈值，等于capacity * loadFactor。

2. Java 8之后的实现：当链表中元素超过8个以后且当前数组的长度小于64，会将链表转换为红黑树，可将查找的时间复杂度降为O(log n)。

> 红黑树
>
> 红黑树是一种特殊的二叉查找树，红黑树上的每个节点都有存储位表示节点的颜色，可以是红或黑。
>
> 红黑树的特征：
>
> 1. 每个节点要么是黑色，要么是红色；
> 2. 根节点是黑色；
> 3. 每个叶子节点是黑色；【注意：叶子节点是指为空（NULL）的节点】
> 4. 如果一个节点是红色，则它的子结点必须是黑色，也就是说，不存在一条路径上有两个相邻的节点都是红色；
> 5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
>
> 特性5确保没有一条路径会比其他路径长出两倍。因而红黑树是相对接近平衡的二叉树。

扩容：

+ 1.7：将数组扩大为原来的2倍，一个for循环遍历原数组，在循环体里面，通过do-while循环遍历桶里的元素，将元素重新哈希到新的数组桶里，采用头插法。多线程情况下，两个线程同时对其扩容，会形成环状结构，造成死循环。
+ 1.8：将数组扩大为原来的2倍，一个for循环遍历原数组，在循环体里遍历每个桶里的元素。原来桶里的元素可以分为两部分，一部分应该放的位置跟原数组下标一样的桶，另一部分放在原下标+原数组长度的桶，因此遍历原来的链表，将这个链表分为两个子链表，元素顺序不变，不会形成环。

#### Hashtable

线程安全，已不推荐使用。

Hashtable的key不能为null。

#### TreeMap

Tree底层由红黑树实现，查找结点的时间复杂度是O(log n)。所有的键都要实现Comparable接口，覆写compareTo()方法。当用Iterator遍历TreeMap时，得到的记录是排好序的。

非线程安全。

#### LinkedHashMap

LinkedHashMap可以认为是HashMap + LinkedList，即它通过HashMap的实现来查找、插入，又使用LinkedList来维护元素插入的先后顺序。

LinkedHashMap的实现思想是**多态** 。

LinkedHashMap的Entry多了两个属性：

+ Entry<K, V> before
+ Entry<K, V> after

不要搞混了next和before、after，next指向的是同一个Hash桶中的下一个元素，before、after用于维护元素插入的先后顺序。

非线程安全。