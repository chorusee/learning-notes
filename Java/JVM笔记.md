### JVM笔记

#### JVM内存模型和分区-详细到每个区放什么

![image-20210518233526934](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210518233526934.png)

##### 程序计数器（PCR）

线程私有的，唯一一个没有规定OOM的区域。

##### Java虚拟机栈

线程私有的。

每个方法被执行的时候，Java虚拟机会同步创建一个栈帧用于存储局部变量、操作数栈、动态连接、方法出口等信息。

局部变量表中存放了编译器可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型。

《Java虚拟机规范》对这个内存区域规定了两种异常情况：

+ 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`
+ 如果Java虚拟机可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OOM异常（HotSpot栈容量不可动态扩展）

##### 本地方法栈

线程私有的。

Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用本地方法服务。与虚拟机栈一样也会抛出`StackOverflowError`异常与OOM异常。

##### Java堆

被所有内存共享的一块区域，在虚拟机启动时创建。此区域的唯一目的是存放对象实例，Java中“几乎”所有的对象实例都在这里分配内存。

如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展，Java虚拟机将会抛出OOM异常。

##### 方法区

各个线程共享的内存区域，它用于存储已被虚拟机加载的类的元信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但它有一个别名“非堆”，目的是与Java堆区分开来。

《Java虚拟机规范》中规定了方法区这个概念和它的作用，并没有规定如何实现。JDK 1.7之前HotSpot用永久代来实现方法区，对于Java 8，HotSpot用元空间和堆取代了永久代。不同点：

+ 存储位置不同，永久代是堆的一部分，和新生代、老年代地址是连续的，而元空间属于本地内存
+ 存储内容不同，元空间存储类的元信息，而静态变量和常量等并入堆中

如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

#### 对象的创建

1. Java虚拟机执行到new指令时，会检查要新建的对象的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的加载过程。

2. 类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。分两种情况：

   + 假如Java堆中的内存是规整的，那分配内存就仅仅是把指针向空闲空间挪动一段位置。这种分配方式称为“指针碰撞”。
   + 如果Java堆中的内存并不规整，需要在空闲链表中找到一块足够大的空间。这种分配方式称为“空闲列表”。

   除如何划分空间外，还要考虑并发的情况，解决这个问题有两种可选方案：

   + 对分配内存动作进行同步处理
   + 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即为每个线程在堆中预先划分一小块内存，称为“本地线程分配缓冲”

3. 内存分配完成之后虚拟机需要将分配到的内存空间都初始化为零值。

4. 接下来设置对象的对象头信息，包括这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

5. 这些工作完成之后，对虚拟机来说，一个新对象已经产生。当从Java程序的角度来看，构造方法还未执行。所以接下来会执行Class文件中的<init>()方法。

##### 对象的内存布局

在HotSpot中，对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。

![image-20210519010507914](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210519010507914.png)

##### 对象访问定位

1. 通过句柄

![image-20210519091142053](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210519091142053.png)

对象被移动时reference本身不会被修改，只会修改句柄中的实例数据指针。

2. 直接指针

   速度快，节省了一次指针定位的开销。HotSpot使用这种方式。

#### 堆里面的分区有哪些？

##### 新生代

##### 老年代

#### GC算法有哪些？标记清除、标记整理、复制算法、引用计数

##### 引用计数算法

需要用到额外的空间存储计数器。不能解决循环依赖问题。

##### 可达性分析算法

从“GC Roots”对象开始根据引用关系向下搜索，不可达的对象是不再使用的。

GC Roots包括以下几种：

+ 在虚拟机栈中引用的对象

+ 在方法区中类静态属性引用的对象

+ 方法区中常量引用的对象

+ JNI引用的对象

  ...

##### 分代收集理论

建立在两个分代假说之上：

+ 弱分代假说：大多数对象都是朝生夕死
+ 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡

这两个分代假说共同奠定了多款常用的垃圾收集器的一致设计原则：

收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域中存储。针对不同区域安排与里面存储的对象存亡特征相匹配的垃圾收集算法。

##### 标记-清除算法

分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成之后，统一回收所有被标记的对象。主要缺点有两个：

+ 执行效率不稳定，如果Java堆中包含大量对象，而且大部分是要回收的，这时必须进行大量标记和清除动作。
+ 会导致内存空间的碎片化问题。

##### 标记-复制算法

为了解决标记-清除算法的问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另一块，清除这一块。缺点是将可用内存缩小了原来的一半。解决了内存碎片化问题。

##### 标记-整理算法

其中的标记过程任然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向内存空间一端移动，然后清理掉边界以外的内存。

#### 经典垃圾收集器

![image-20210520094929527](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210520094929527.png)

1. Serial收集器

   历史最悠久的收集器，负责新生代垃圾收集。是HotSpot客户端模式下默认的新生代收集器。

   + 缺点：只能单线程工作，它在垃圾回收时，必须暂停其他所有工作线程，直到收集结束。
   + 优点：简单而高效，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。微服务应用中分给虚拟机管理的内存不大，垃圾收集停顿时间能控制在100毫秒以内，完全可以接受。

2. ParNew收集器

   实际上是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括控制参数、收集算法、对象分配规则等完全一致。服务器模式下的HotSpot很多用到这个收集器，除了Serial外，只有它能与CMS配合。ParNew是激活CMS后的默认新生代收集器。

   在单核心处理器环境中不比Serial高效，甚至由于切换上下文，还比不上Serial。

3. Parallel Scavenge收集器

   也是一款新生代收集器，同样基于标记复制算法实现，也是能够并行收集的多线程收集器。

   CMS等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。即其他收集器主要目的是保证服务响应质量，而PS收集器目的是尽快完成程序的运算任务，适用于不需要太对交互的分析任务。

4. Serial Old收集器

   是Serial收集器的老年版本，同样是一个单线程收集器，使用标记整理算法。这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。

5. Parallel Old收集器

   Parallel Old是Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记整理算法。

   主要是与Parallel Scavenge搭配在注重吞吐量或处理器资源比较稀缺的环境下工作。

6. CMS收集器

   CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前大部分Java应用基于B/S系统的服务器端上，这类应用比较关注服务的响应速度，希望停顿时间尽可能短，以给客户带来良好交互体验。

   从名字（包含"Mark Sweep"）上可以看出，CMS基于标记清除算法实现，它的运作过程分四个步骤：

   1）初始标记

   2）并发标记

   3）重新标记

   4）并发清除

   其中初始标记、重新标记两个步骤任然需要"Stop The Word"。初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快。

   并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长且但并不需要停顿用户线程。

   重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿通常比初始标记稍长一些。

   最后并发清除阶段，清理删除掉标记阶段已经判断死亡的对象，由于不需要移动存活对象，所以这个阶段也可以与用户线程同时并发。

   由于整个过程中耗时最长的并发标记与并发清除阶段都能与用户线程一起工作，所以总体上说，CMS垃圾收集器的内存回收过程是与用户线程一起并发执行的。

   ![image-20210520103241278](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210520103241278.png)

   缺点：

   + 首先CMS对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部份线程导致应用程序执行变慢，降低吞吐量。

   + 然后，由于CMS收集器无法处理“浮动垃圾”会导致“并发失败”，进而导致另一次完全“Stop The World”的Full GC。调用后备预案：冻结用户进程执行，临时启用Serial Old收集器进行老年代垃圾回收。

   + 会产生很多空间碎片，会给大对象分配带来麻烦。

7. G1收集器

   垃圾收集技术发展史上里程碑式的成果，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。JDK 9成为服务端模式下的默认垃圾收集器，CMS被标记为不推荐使用。

   G1地设计目标是建立“停顿时间模型”，即能够支持在一个长度为M毫秒的时间片段内，消耗在垃圾回收上的时间不超过N毫秒这样的目标。

   它并非纯粹追求低延迟，而是在延迟可控地情况下尽可能提高吞吐量。

   在G1之前的垃圾收集器，垃圾收集的目标范围要么在整个新生代，那么在整个老年代，或者整个Java堆。G1可以面向堆内任何部分来组成回收集进行回收。衡量标准不再是它属于哪个分代，而是哪块内存垃圾多，回收收益大。

   G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的Region，每一个Reign可以根据需要，扮演新生代的Eden区，幸存区，或老年代空间。G1将Region作为单次回收的最小单元，即每次回收到的内存空间都是Region的整数倍。

   G1去跟踪各个Region里的垃圾堆积的“价值”大小，然后在后台维护一个优先级列表，每次根据用户给的期望停顿时间，优先处理回收价值收益最大的Region。

   从整体上看是标记清除算法，从局部上看又是基于标记复制算法。不会产生空间碎片。

   优点：

   + 可以指定最大停顿时间
   + 分Region的内存布局
   + 按收益动态确定回收集
   + 无空间碎片

   缺点：

   + 内存占用和程序运行时的额外执行负载都要比CMS高

   运行过程：

   1）初始标记

   2）并发标记

   3）最终标记

   4）筛选回收

8. ZGC

   基于Region布局的不设分代的，使用了读屏障等技术实现可并发的标记-整理算法，以低延迟为首要目标的垃圾收集器。

#### 如何选择垃圾收集器？

要看程序的主要关注点是什么，如果是数据分析、科学计算类的任务，目标是尽快算出结果，那么吞吐量就是主要关注点。如果是Web服务器应用，那停顿时间直接影响服务质量，这样延迟就是主要关注点。如果是嵌入式应用， 那么垃圾收集的内存占用不可忽视。

#### GC常用参数

查看GC详细信息：

```
# JDK 9之前
-XX:PrintGCDetails
# JDK 9之后
-X-log:gc*
```



![image-20210520112936327](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210520112936327.png)

#### 轻GC和重GC分别在什么时候发生

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

`-XX:+PrintGCDetail`告诉虚拟机在发生垃圾收集时打印内存回收日志。

大对象直接进入老年代。在为大对象分配空间时，容易出现明明还有不少空间，但时找不到一块能容纳大对象的完整的连续空间，提前触发垃圾回收。当复制大对象时，意味着高额的内存复制开销。

`-XX:PretenureSizeThreshold`参数，指定大于该设置的对象直接在老年代分配，这样做的目的是避免在Eden区以及两个幸存区之间来回复制。

长期存活的对象进入老年代。虚拟机为每个对象定义了一个对象年龄计数器，存储在对象头中。对象在幸存区每熬过一次Minor GC，年龄就加一。当它的年龄增加到一定程度（默认15）就晋升到老年代中。

`-XX:MaxTenuringThreshold`设置年龄阈值。

动态年龄判断：并不是一定要年龄大于阈值才进入老年代。当幸存区中相同年龄所有对象的大小大于幸存空间的一半，大于这个年龄的都进入老年代。

空间分配担保：在发生MinorGC之前，必须检查老年代的最大连续可用空间是否大于新生代所有对象的总空间，如果是，那么Minor GC可以确保安全。否则，接着会查看是否允许担保失败。如果允许，继续查看老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果是，则尝试一次Minor GC，尽管这次Minor GC是有风险的。**如果小于则进行一次Full GC**。 

##### 常用性能监控和故障处理工具

1. jps：虚拟机进程状况工具。跟linux的ps命令类似，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID。

2. jstat：虚拟机统计信息监控工具。用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。

3. jinfo：Java配置信息工具。实时查看和调整虚拟机各项参数。

4. jmap：Java内存映像工具。用于生成堆转储快照。也可以使用`-XX:+HeapDumpOnOutOfMemoryError`。jamp还可以查询Java堆和方法区的详细信息，如空间使用率、当前使用的是那种收集器等。

   `-dump`生成Java堆转储快照；

   `-heap`显示Java堆详细信息；

5. jstack：Java堆栈跟踪工具。用于生成当前时刻的线程快照。线程快照是当前虚拟机内每一条正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因。

6. VisualVM：运行监控和故障处理工具。

7. JMC：可持续在线的监控工具。

### 类加载机制

类的声明周期

![image-20210525121405693](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210525121405693.png)

#### 加载

1. 通过一个类的全限定名来获取定义此类的二进制字节流；
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

#### 验证

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符文《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。

1. 文件格式验证；

2. 元数据验证；

   + 这个类是否有父类
   + 这个类是否继承了不允许被继承的类
   + 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
   + 类中的字段、方法是否与父类产生矛盾

3. 字节码验证

   对类的方法体进行校验分析，保证类的方法再运行时不会做出危害虚拟机的行为。

4. 符号引用验证

   + 符号引用中通过字符串描述的全限定名是否能找到对应的类
   + 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段

#### 准备

正式为类中定义的静态变量分配内存并设置类变量初始值。

#### 解析

虚拟机将常量池内的符号引用替换为直接引用的过程。

#### 初始化

类加载过程的最后一步，执行类构造其`<clinit>()`方法。这个方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并而成。

### 类与类加载器

对于任何一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

#### 双亲委派模型

站在虚拟机的角度，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap Class Loader），用C++实现，是虚拟机自身的一部分；另一种是其他所有的类加载器，这些类加载器由Java语言实现，独立存在于虚拟机外部，并且全部继承自`java.lang.ClassLoader`。

站在开发人员的角度，有三层类加载器：

1. 启动类加载器：这个类加载器负责加载位于`<JAVA_HOEM>/lib`目录下，或者被`-Xbootclasspath`参数指定的路径下的类。而且这些类库名字必须能被虚拟机识别（如rt.jar、tools.jar）。
2. 扩展类加载器（Extension Class Loader）：这个类加载器以Java代码实现，负责加载`<JAVA_HOME>/lib/ext`目录下的类库。用户可以将具有通用性的类库放在这个目录下以扩展Java SE的功能。开发者可以直接使用这个类加载器。
3. 应用程序类加载器（Application Class Loader）：这个类加载器由Java实现。它负责加载用户类路径（ClassPath）下所有的类库，开发者可以直接在代码中使用这个类加载器。

双亲委派模型的父子关系不是由继承关系实现，而是以组合关系实现。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

好处：

+ Java中的类有了一种带有优先级的层次关系。如自己编写了一个`java.lang.Obejct`类，无论哪个加载器要加载这个类，最终都会委托给启动类加载器，在rt.jar中找到，因此能保证各级类加载器加载的都是同一个类，保证了Java类型体系的基础行为。
+ 不会重复加载类
+ 保证安全，比如外部的有危险代码的`java.lang.String`不会被加载



#### Java模块化系统

JAR包不仅仅是简单的充当代码的容器了，除了代码之外，Java模块还包含了一下内容：

+ 依赖其他模块的列表
+ 导出的包的列表，即其他模块可使用的列表
+ 使用的服务列表
+ 提供的服务列表

解决了基于类路径来查找依赖的可靠性问题，如果类路径中缺失了运行时的依赖，只有等程序运行到该类型加载是才会抛出异常。

模块化下的扩展类加载器被平台加载器取代了。





### Java内存模型与线程

Java内存模型（Java Memory Model，JMM）用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存中和从内存中取出变量这样的底层细节。

Java内存模型规定所有的变量都存储在主存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的内存副本。线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主存中的数据。不同的线程之间也无法直接访问对方内存中的变量，线程间变量的传递需要通过主存来完成。

![image-20210525153346181](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210525153346181.png)

#### 内存间交互操作

+ lock：作用于主存中的变量，它把一个变量表示为一条线程独占状态。
+ unlock：作用与主存中的变量，它把一个处于锁定中的变量释放出来，释放后的变量才可以被其他线程锁定。
+ read：作用于主存中的变量，它把一个变量的值从主内存传输到线程工作内存中，以便随后的load动作使用。
+ load：作用于工作内存中的变量，它把read操作从主存中得到的变量值放入工作内存中的变量副本中。
+ use：作用于工作内存的变量，它把工作内存中的一个变量传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时，将会执行这个操作。
+ assign：作用于工作内存中的变量，它把一个从执行引擎接受的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
+ store：作用于工作内存的变量，它把工作内存中一个变量的值传送到主存，以便随后的write操作。
+ write：作用于主存的变量，它把store操作从工作内存中得到的变量的值放入主存中的变量中。

可以将其简化为read、write、lock和unlock四种。

#### volatile型变量

它具备两项特性：

+ 保证此变量对所有线程的可见性，这里的“可见性”是指当一个线程修改了这个变量的值，新值对于其他线程来说是立即得知的。
+ 禁止指令重排优化。

#### 原子性、可见性和有序性

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性三个特征来建立的。

1. 原子性：基本数据类型的访问、读写都具有原子性（例外：long和double的非原子性协定）
2. 可见性：一个线程修改了共享变量时，其他线程能够立即得知这个修改。
3. 有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

#### 线程的状态

![image-20210525190901815](C:\Users\yxlself\AppData\Roaming\Typora\typora-user-images\image-20210525190901815.png)

#### ReentrantLock对比synchronized

+ 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他的事情。
+ 公平锁：两者默认都是非公平锁，但是可以通过带布尔参数的构造方法要求使用公平锁。
+ 绑定多个条件：一个可重入锁可以同时绑定多个Condition对象。

#### 锁

1. 自旋锁：挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给虚拟机的并发性能带来了很大的压力。而很多应用上，共享数据只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。在多核处理器上，可以让后面请求锁的那个线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否会很快释放锁。为了让线程等待，我们必须让线程执行一个忙循环（自旋），这项技术就是自旋锁。

2. 轻量级锁：传统的锁由互斥量来实现，这种同步方式成本非常高，要经过用户态和内核态的切换，因此称为重量级锁。轻量级锁的设计初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

   使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节通过CAS操作更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功。记录锁状态为轻量级锁。否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争，接下来膨胀为重量级锁，更改锁标志。

3. 偏向锁：目的是消除在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争情况下使用CAS操作消除同步使用的互斥量，那么偏向锁就是在无竞争情况下把整个同步都消除，连CAS操作都不去做了。

   偏向锁的“偏”是“偏心”的“偏”，它的意思是这个锁会偏向于第一个获得他的线程，如果接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

   一旦出现另一个线程去尝试获取这个锁，偏向模式立即结束。

