### 进程间通信

#### 管道

管道是一种通信机制，通常用于进程间通信，它表现出来的形式将前一个进程的输出直接作为后一个进程的输入。

如：

`ls -l | cat test`

其中`ls`和`cat`是两个程序，`|`代表管道，意思是执行`ls -l`并将其输出作为`cat test`的输入。

管道的五大特点：

+ 匿名管道只能单向通信
+ 管道只能用于有亲缘关系的进程间通信，通常用于父子进程
+ 可以将它看成特殊的文件，对于它的读写可以使用read、write等函数。但它不属于任何文件系统，只存在于内存
+ 管道的通信面向字节流
+ 管道自带同步机制，保证读写顺序一致

管道分为`pipe（匿名管道）`和`FIFO（命名管道）`两种，除了建立、打开、删除的方式不同外，这两种管道几乎是一样的。它们都是通过内核缓冲区实现数据传输。

+ pipe用于相关进程之间的通信，例如父进程和子进程，它通过pipe()系统调用来创建并打开，当最后一个使用它的进程关闭对他的引用时，pipe将自动撤销。
+ FIFO即命名管道，和无名管道的主要区别在于，命名管道有一个名字，命名管道的名字对应于一个磁盘索引节点，有了这个文件名，任何进程有相应的权限都可以对它进行访问。当一个命名管道不再被任何一个进程打开时，他没有消失，还可以再次被打开，就像打开一个磁盘文件一样。

管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据。

#### 消息队列

消息队列就是消息的链表，是一系列保存在内核中消息的列表。

##### 消息队列产生的原因

既然有了管道，为什么还需要消息队列呢？这是因为：

+ 生命周期：匿名管道的生命周期随着进程结束而结束
+ 传送方式：管道以字节流方式传送数据，给程序开发带来了不便
+ 数据大小限制：管道传送的数据量受到缓冲区大小的限制

消息队列与管道的不同在于：消息队列是基于消息的，而管道是基于字节流的；消息队列的读取不一定是先进先出，而且如果没有显示删除它，在关机之前一直存在。

#### 共享内存

内存共享，顾名思义就是允许两个不相关的进程访问同一块存储区，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。

共享内存并未提供同步机制，所以通常需要其他机制来同步对共享内存的访问，如信号量。

##### 共享内存原理

在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Address Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址将进行映射，通过内存管理单元（MMU）进行管理。两个不停的虚拟地址通过页表映射到物理空间的同一区域，他们所指向的这块区域即共享内存。

##### 共享内存的接口函数以及指令

+ 查看系统中的共享存储段

  `ipcs -m`

+ 删除系统中的共享存储块

  `ipcrm -m [shmid]`

+ 创建共享内存

  ```C
  int shmget(key_t key, size_t size, int shmflg);
  ```

  参数：

  + key 由ftok生成的key标识，标识系统的唯一IPC资源
  + size 需要申请共享内存的大小。页大小（4k）的整数倍
  + shmflg 如果要创建新的共享内存，需要使用`IPC_CREAT`和`IPC_EXCL`；如果是已经存在的，可以使用IPC_CREAT或直接传0

  返回值：

  成功时返回一个新建的或已存在的共享内存标识符。失败返回-1并设置错误码。

+ 连接共享内存

  ```c
  void *shmat(int shmid, const void *shmaddr, int shmflg);
  ```

  参数：

  + shmid 共享存储段标识符
  + shmaddr shmaddr = 0，则存储段连接到由内核选择的第一个可用地址上（推荐使用）
  + shmflg 若指定了SHM_RDONLY，则以只读方式连接此段，否则以读写方式连接此段

  返回值：

  成功返回共享存储段的指针（虚拟地址），并且内核将其与该共享存储段相关的shmid_ds结构中的shm_nattch计数器加1；出错返回-1

+ 去关联共享内存

  ```c
  int shmdt(const void *shmaddr);
  ```

  参数：

  + shmaddr 连接以后返回的地址

  返回值：

  成功返回0，并将shmid_ds结构体中的shm_nattch计数器减1；出错返回-1

+ 销毁共享内存

  ```c
  int shmctl(int shmid, int cmd, struct shmid_ds *buf);
  ```

  参数：

  + shmid 共享内存段标识符
  + cmd 指定的执行操作，设置为IPC_RMID时表示可以删除共享内存段
  + buf 设置为NULL即可

  返回值：

  成功返回0；出错返回-1

##### 总结

优点：通过共享内存进行进程间的通信非常方便，函数接口也比较简单，进程间的数据共享不用传送，而是直接访问内存，效率高。

缺点：共享内存没有提供同步机制，这使得在使用共享内存进行进程间通信时往往要借助其他的手段来保证进程间的同步工作。

#### 信号量

信号量（semaphore）与前面的IPC结构不同，它是一个计数器。信号量用于实现进程间的同步与互斥，而不是用于存储进程间的通信数据。

##### 信号量引入原因

为了防止多个进程访问统一资源而引发一系列问题，需要一种机制来授权访问临界资源，在任意时刻只有一个线程执行访问代码的临界区。信号量提供了这样的机制。即信号量时用来协调进程对资源的访问的。

临界资源：一次只允许一个进程/线程使用的资源称为临界资源，如打印机

临界区：临界区内的数据和代码同时智能由一个进程/线程使用、执行，当一个进程/线程进入临界区时，另一个进程/线程需要等待

##### 特点

+ 信号量用于进程间同步，若要在进程间传送数据需要结合共享内存
+ 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
+ 每次信号量的PV操作不仅限于对信号量加1减1，而是可以加减任意正整数
+ 支持信号量组

##### 信号量工作原理

信号量只能进行两种操作，P(sv)和V(sv)，sv为信号量，表示当前可用资源的数量

P(sv)：如果sv的值大于0，就对其减1，进入临界区；如果为0，就挂起该进程

V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行；如果没有进程因等待sv而被挂起，就加1

